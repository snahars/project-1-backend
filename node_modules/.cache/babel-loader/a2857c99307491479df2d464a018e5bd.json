{"ast":null,"code":"import _objectSpread from \"/home/sunipa/projects/sncworkspace/ntl-snc_frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(saga);\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport { persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport { put, takeLatest } from \"redux-saga/effects\";\nimport { getUserByToken } from \"./authCrud\";\nexport var actionTypes = {\n  Login: \"[Login] Action\",\n  Logout: \"[Logout] Action\",\n  Register: \"[Register] Action\",\n  UserRequested: \"[Request User] Action\",\n  UserLoaded: \"[Load User] Auth API\",\n  SetUser: \"[Set User] Action\"\n};\nvar initialAuthState = {\n  user: undefined,\n  authToken: undefined\n};\nexport var reducer = persistReducer({\n  storage: storage,\n  key: \"v726-demo1-auth\",\n  whitelist: [\"authToken\"]\n}, function () {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialAuthState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case actionTypes.Login:\n      {\n        var authToken = action.payload.authToken;\n        return {\n          authToken: authToken,\n          user: undefined\n        };\n      }\n\n    case actionTypes.Register:\n      {\n        var _authToken = action.payload.authToken;\n        return {\n          authToken: _authToken,\n          user: undefined\n        };\n      }\n\n    case actionTypes.Logout:\n      {\n        // TODO: Change this code. Actions in reducer aren't allowed.\n        return initialAuthState;\n      }\n\n    case actionTypes.UserLoaded:\n      {\n        var user = action.payload.user;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          user: user\n        });\n      }\n\n    case actionTypes.SetUser:\n      {\n        var _user = action.payload.user;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          user: _user\n        });\n      }\n\n    default:\n      return state;\n  }\n});\nexport var actions = {\n  login: function login(authToken) {\n    return {\n      type: actionTypes.Login,\n      payload: {\n        authToken: authToken\n      }\n    };\n  },\n  register: function register(authToken) {\n    return {\n      type: actionTypes.Register,\n      payload: {\n        authToken: authToken\n      }\n    };\n  },\n  logout: function logout() {\n    return {\n      type: actionTypes.Logout\n    };\n  },\n  requestUser: function requestUser(user) {\n    return {\n      type: actionTypes.UserRequested,\n      payload: {\n        user: user\n      }\n    };\n  },\n  fulfillUser: function fulfillUser(user) {\n    return {\n      type: actionTypes.UserLoaded,\n      payload: {\n        user: user\n      }\n    };\n  },\n  setUser: function setUser(user) {\n    return {\n      type: actionTypes.SetUser,\n      payload: {\n        user: user\n      }\n    };\n  }\n};\nexport function saga() {\n  return _regeneratorRuntime().wrap(function saga$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return takeLatest(actionTypes.Login, /*#__PURE__*/_regeneratorRuntime().mark(function loginSaga() {\n            return _regeneratorRuntime().wrap(function loginSaga$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return put(actions.requestUser());\n\n                  case 2:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, loginSaga);\n          }));\n\n        case 2:\n          _context4.next = 4;\n          return takeLatest(actionTypes.Register, /*#__PURE__*/_regeneratorRuntime().mark(function registerSaga() {\n            return _regeneratorRuntime().wrap(function registerSaga$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return put(actions.requestUser());\n\n                  case 2:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, registerSaga);\n          }));\n\n        case 4:\n          _context4.next = 6;\n          return takeLatest(actionTypes.UserRequested, /*#__PURE__*/_regeneratorRuntime().mark(function userRequested() {\n            var _yield$getUserByToken, user;\n\n            return _regeneratorRuntime().wrap(function userRequested$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.next = 2;\n                    return getUserByToken();\n\n                  case 2:\n                    _yield$getUserByToken = _context3.sent;\n                    user = _yield$getUserByToken.data;\n                    _context3.next = 6;\n                    return put(actions.fulfillUser(user));\n\n                  case 6:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, userRequested);\n          }));\n\n        case 6:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"names":["saga","persistReducer","storage","put","takeLatest","getUserByToken","actionTypes","Login","Logout","Register","UserRequested","UserLoaded","SetUser","initialAuthState","user","undefined","authToken","reducer","key","whitelist","state","action","type","payload","actions","login","register","logout","requestUser","fulfillUser","setUser","loginSaga","registerSaga","userRequested","data"],"sources":["/home/sunipa/projects/sncworkspace/ntl-snc_frontend/src/app/modules/Auth/_redux/authRedux.js"],"sourcesContent":["import { persistReducer } from \"redux-persist\";\r\nimport storage from \"redux-persist/lib/storage\";\r\nimport { put, takeLatest } from \"redux-saga/effects\";\r\nimport { getUserByToken } from \"./authCrud\";\r\n\r\nexport const actionTypes = {\r\n  Login: \"[Login] Action\",\r\n  Logout: \"[Logout] Action\",\r\n  Register: \"[Register] Action\",\r\n  UserRequested: \"[Request User] Action\",\r\n  UserLoaded: \"[Load User] Auth API\",\r\n  SetUser: \"[Set User] Action\",\r\n};\r\n\r\nconst initialAuthState = {\r\n  user: undefined,\r\n  authToken: undefined,\r\n};\r\n\r\nexport const reducer = persistReducer(\r\n  { storage, key: \"v726-demo1-auth\", whitelist: [\"authToken\"] },\r\n  (state = initialAuthState, action) => {\r\n    switch (action.type) {\r\n      case actionTypes.Login: {\r\n        const { authToken } = action.payload;\r\n\r\n        return { authToken, user: undefined };\r\n      }\r\n\r\n      case actionTypes.Register: {\r\n        const { authToken } = action.payload;\r\n\r\n        return { authToken, user: undefined };\r\n      }\r\n\r\n      case actionTypes.Logout: {\r\n        // TODO: Change this code. Actions in reducer aren't allowed.\r\n        return initialAuthState;\r\n      }\r\n\r\n      case actionTypes.UserLoaded: {\r\n        const { user } = action.payload;\r\n        return { ...state, user };\r\n      }\r\n\r\n      case actionTypes.SetUser: {\r\n        const { user } = action.payload;\r\n        return { ...state, user };\r\n      }\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n);\r\n\r\nexport const actions = {\r\n  login: (authToken) => ({ type: actionTypes.Login, payload: { authToken } }),\r\n  register: (authToken) => ({\r\n    type: actionTypes.Register,\r\n    payload: { authToken },\r\n  }),\r\n  logout: () => ({ type: actionTypes.Logout }),\r\n  requestUser: (user) => ({\r\n    type: actionTypes.UserRequested,\r\n    payload: { user },\r\n  }),\r\n  fulfillUser: (user) => ({ type: actionTypes.UserLoaded, payload: { user } }),\r\n  setUser: (user) => ({ type: actionTypes.SetUser, payload: { user } }),\r\n};\r\n\r\nexport function* saga() {\r\n  yield takeLatest(actionTypes.Login, function* loginSaga() {\r\n    yield put(actions.requestUser());\r\n  });\r\n\r\n  yield takeLatest(actionTypes.Register, function* registerSaga() {\r\n    yield put(actions.requestUser());\r\n  });\r\n\r\n  yield takeLatest(actionTypes.UserRequested, function* userRequested() {\r\n    const { data: user } = yield getUserByToken();\r\n\r\n    yield put(actions.fulfillUser(user));\r\n  });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}